name: Update fallback cache

on:
  workflow_dispatch: {}
  schedule:
    # Runs at minute 17 of every 7th hour (UTC): 00:17, 07:17, 14:17, 21:17
    # Asia/Taipei (UTC+8): 08:17 / 15:17 / 22:17 / 05:17 (next day)
    - cron: "17 */7 * * *"

permissions:
  contents: write

concurrency:
  group: repo-writer-main
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else
            pip install "requests>=2.31.0"
          fi

      - name: Configure git
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Generate + validate + commit + push (retry-safe, ff-only)
        shell: bash
        env:
          TZ: Asia/Taipei
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail

          # ----------------------------
          # Helper scripts (avoid YAML/indent pitfalls)
          # ----------------------------
          cat > /tmp/regenerate_fallback_manifest_v1.py <<'PY'
          import json, os, datetime
          from pathlib import Path

          repo = os.environ["REPO"]
          sha_data = os.environ["SHA_DATA"]

          # best-effort script_version from latest.json
          script_version = "unknown"
          try:
            rows = json.loads(Path("fallback_cache/latest.json").read_text(encoding="utf-8"))
            if isinstance(rows, list):
              for r in rows:
                if r.get("series_id") == "__META__" and r.get("notes") == "INFO:script_version":
                  script_version = r.get("value") or script_version
                  break
          except Exception:
            pass

          now_utc = datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"
          base = f"https://raw.githubusercontent.com/{repo}/{sha_data}/fallback_cache"

          out = {
            "generated_at_utc": now_utc,
            "as_of_ts": now_utc,
            "script_version": script_version,
            "data_commit_sha": sha_data,
            "pinned": {
              "latest_json":  f"{base}/latest.json",
              "latest_csv":   f"{base}/latest.csv",
              "history_json": f"{base}/history.json",
              # temporary; will be self-pinned by v2 step
              "manifest_json": f"https://raw.githubusercontent.com/{repo}/refs/heads/main/fallback_cache/manifest.json"
            }
          }

          Path("fallback_cache/manifest.json").write_text(
            json.dumps(out, ensure_ascii=False, indent=2) + "\n",
            encoding="utf-8"
          )
          PY

          cat > /tmp/self_pin_manifest.py <<'PY'
          import json, os
          from pathlib import Path

          repo = os.environ["REPO"]
          sha1 = os.environ["MANIFEST_SHA"].strip()

          p = Path("fallback_cache/manifest.json")
          obj = json.loads(p.read_text(encoding="utf-8"))
          obj.setdefault("pinned", {})
          obj["pinned"]["manifest_json"] = f"https://raw.githubusercontent.com/{repo}/{sha1}/fallback_cache/manifest.json"
          obj["manifest_commit_sha_v1"] = sha1

          p.write_text(json.dumps(obj, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
          PY

          # Hard guard: ensure self-pin succeeded AND matches this run's MANIFEST_SHA
          cat > /tmp/assert_self_pin.py <<'PY'
          import json, os
          from pathlib import Path

          repo = os.environ["REPO"]
          manifest_sha = os.environ["MANIFEST_SHA"].strip()

          p = Path("fallback_cache/manifest.json")
          obj = json.loads(p.read_text(encoding="utf-8"))

          u = (obj.get("pinned") or {}).get("manifest_json", "")
          expected = f"https://raw.githubusercontent.com/{repo}/{manifest_sha}/fallback_cache/manifest.json"

          if u != expected:
              raise SystemExit(f"FATAL: self-pin mismatch\n  got:      {u}\n  expected: {expected}")

          msha = str(obj.get("manifest_commit_sha_v1", "")).strip()
          if msha != manifest_sha:
              raise SystemExit(f"FATAL: manifest_commit_sha_v1 mismatch\n  got:      {msha}\n  expected: {manifest_sha}")

          print("OK: self-pin assertions passed.")
          PY

          sleep_for () {
            case "$1" in
              1) sleep 2 ;;
              2) sleep 4 ;;
              3) sleep 8 ;;
            esac
          }

          for attempt in 1 2 3; do
            echo "===== Attempt ${attempt} ====="

            # Always start from latest remote main (ff-only safe pattern)
            git fetch origin main
            git reset --hard origin/main
            git clean -fd

            # 1) Generate files (must produce latest.json/latest.csv/history.json/manifest.json best-effort)
            python scripts/update_fallback_cache.py

            # 2) Validate JSON
            python -m json.tool fallback_cache/latest.json > /dev/null
            python -m json.tool fallback_cache/history.json > /dev/null
            python -m json.tool fallback_cache/manifest.json > /dev/null
            echo "latest/history/manifest JSON valid."

            # Required files check
            test -f fallback_cache/latest.json
            test -f fallback_cache/latest.csv
            test -f fallback_cache/history.json
            test -f fallback_cache/manifest.json

            # 3) Commit DATA (latest + history)
            git add fallback_cache/latest.json fallback_cache/latest.csv fallback_cache/history.json
            if git diff --cached --quiet; then
              echo "No DATA changes to commit. Exit."
              exit 0
            fi

            git commit -m "Update fallback DATA (latest json/csv + history)" || true
            SHA_DATA="$(git rev-parse HEAD)"
            export SHA_DATA
            echo "SHA_DATA=$SHA_DATA"

            if ! git push origin HEAD:main; then
              echo "Push DATA failed (non-ff). Retry..."
              sleep_for "${attempt}"
              continue
            fi
            echo "Push DATA OK."

            # 4) Regenerate manifest v1 (pinned to SHA_DATA)
            python /tmp/regenerate_fallback_manifest_v1.py
            python -m json.tool fallback_cache/manifest.json > /dev/null
            echo "manifest v1 valid."

            git add fallback_cache/manifest.json
            if git diff --cached --quiet; then
              echo "No MANIFEST(v1) changes to commit."
              exit 0
            fi

            git commit -m "Update fallback MANIFEST (pinned data urls)" || true
            MANIFEST_SHA="$(git rev-parse HEAD)"
            export MANIFEST_SHA
            echo "MANIFEST_SHA=$MANIFEST_SHA"

            if ! git push origin HEAD:main; then
              echo "Push MANIFEST(v1) failed. Retry..."
              sleep_for "${attempt}"
              continue
            fi
            echo "Push MANIFEST(v1) OK."

            # 5) Self-pin manifest_json -> MANIFEST_SHA (v2)
            python /tmp/self_pin_manifest.py
            python -m json.tool fallback_cache/manifest.json > /dev/null
            echo "manifest self-pin valid."

            # 5.1) HARD GUARD (must be pinned to this run's MANIFEST_SHA)
            python /tmp/assert_self_pin.py

            git add fallback_cache/manifest.json
            if git diff --cached --quiet; then
              echo "No MANIFEST(v2) changes. Done."
              exit 0
            fi

            git commit -m "Update fallback MANIFEST (pin manifest url)" || true
            if ! git push origin HEAD:main; then
              echo "Push MANIFEST(v2) failed. Retry..."
              sleep_for "${attempt}"
              continue
            fi

            echo "Push MANIFEST(v2) OK. Done."
            exit 0
          done

          echo "ERROR: failed after 3 attempts."
          exit 1